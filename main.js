/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => PropertyHiderPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  properties: []
};
var PropertyHiderPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new PropertyHiderSettingTab(this.app, this));
    this.updateCSS();
    this.addCommands();
  }
  addCommands() {
    this.settings.properties.forEach((prop, index) => {
      this.addCommand({
        id: `toggle-${prop.name.toLowerCase().replace(/[^a-z0-9]/g, "-")}`,
        name: `Toggle visibility: ${prop.name}`,
        callback: async () => {
          this.toggleProperty(index);
          await this.saveSettings();
        }
      });
    });
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.updateCSS();
    this.refreshCommands();
  }
  refreshCommands() {
    const appAny = this.app;
    appAny.commands.removeCommand = appAny.commands.removeCommand || function(id) {
      delete this.commands[id];
      delete this.editorCommands[id];
    };
    Object.keys(appAny.commands.commands).forEach((id) => {
      if (id.startsWith(this.manifest.id + ":toggle-")) {
        appAny.commands.removeCommand(id);
      }
    });
    this.addCommands();
  }
  onunload() {
    this.removeCSS();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  updateCSS() {
    this.removeCSS();
    const hiddenProperties = this.settings.properties.filter((prop) => prop.hidden).map((prop) => `.metadata-property[data-property-key="${prop.name}"]`).join(",\n");
    if (hiddenProperties) {
      const css = `${hiddenProperties} { display: none !important; }`;
      const style = document.createElement("style");
      style.id = "property-hider-style";
      style.textContent = css;
      document.head.appendChild(style);
    }
  }
  removeCSS() {
    const existing = document.getElementById("property-hider-style");
    if (existing)
      existing.remove();
  }
  addProperty(name) {
    if (!name || this.settings.properties.some((p) => p.name === name))
      return false;
    this.settings.properties.push({ name, hidden: true });
    return true;
  }
  deleteProperty(index) {
    this.settings.properties.splice(index, 1);
  }
  toggleProperty(index) {
    this.settings.properties[index].hidden = !this.settings.properties[index].hidden;
  }
  renameProperty(index, newName) {
    if (!newName || this.settings.properties.some((p, i) => p.name === newName && i !== index))
      return false;
    this.settings.properties[index].name = newName;
    return true;
  }
};
var PropertyHiderSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h3", { text: "Hidden Properties" });
    let inputEl;
    new import_obsidian.Setting(containerEl).setName("Add Property").setDesc("Enter property name to hide in the ").addText((text) => {
      inputEl = text.inputEl;
      text.setPlaceholder("Property name");
      text.inputEl.addEventListener("keypress", async (e) => {
        if (e.key === "Enter") {
          const name = text.inputEl.value.trim();
          if (this.plugin.addProperty(name)) {
            await this.plugin.saveSettings();
            text.inputEl.value = "";
            this.display();
          }
        }
      });
    }).addButton((button) => {
      button.setIcon("plus").setTooltip("Add property").setCta().onClick(async () => {
        const name = inputEl.value.trim();
        if (this.plugin.addProperty(name)) {
          await this.plugin.saveSettings();
          inputEl.value = "";
          this.display();
        }
      });
    });
    if (this.plugin.settings.properties.length > 0) {
      this.plugin.settings.properties.forEach((prop, index) => {
        new import_obsidian.Setting(containerEl).addText((text) => {
          text.setValue(prop.name).onChange(async (value) => {
            if (value.trim() && this.plugin.renameProperty(index, value.trim())) {
              await this.plugin.saveSettings();
            }
          });
        }).addButton((button) => {
          button.setIcon(prop.hidden ? "eye-off" : "eye").setTooltip(prop.hidden ? "Show property" : "Hide property").onClick(async () => {
            this.plugin.toggleProperty(index);
            await this.plugin.saveSettings();
            this.display();
          });
        }).addButton((button) => {
          button.setIcon("trash").setTooltip("Delete property").setWarning().onClick(async () => {
            this.plugin.deleteProperty(index);
            await this.plugin.saveSettings();
            this.display();
          });
        });
      });
    }
  }
};
